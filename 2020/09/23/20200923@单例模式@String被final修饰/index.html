<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>20200923@单例模式@String被final修饰 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="单例模式​        单例模式（Singleton Pattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 ​        这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 解法一：只适用于单线程1234567891011">
<meta property="og:type" content="article">
<meta property="og:title" content="20200923@单例模式@String被final修饰">
<meta property="og:url" content="https://honorzmj98.github.io/2020/09/23/20200923@%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F@String%E8%A2%ABfinal%E4%BF%AE%E9%A5%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="单例模式​        单例模式（Singleton Pattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 ​        这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 解法一：只适用于单线程1234567891011">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-23T12:38:23.626Z">
<meta property="article:modified_time" content="2020-09-23T17:00:35.182Z">
<meta property="article:author" content="HonorZmj98">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://HonorZmj98.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-20200923@单例模式@String被final修饰" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/23/20200923@%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F@String%E8%A2%ABfinal%E4%BF%AE%E9%A5%B0/" class="article-date">
  <time datetime="2020-09-23T12:38:23.626Z" itemprop="datePublished">2020-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      20200923@单例模式@String被final修饰
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>​        单例模式（Singleton Pattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>​        这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h2 id="解法一：只适用于单线程"><a href="#解法一：只适用于单线程" class="headerlink" title="解法一：只适用于单线程"></a>解法一：只适用于单线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 me;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">			me = <span class="keyword">new</span> Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> me;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们将构造函数设置为私有（<code>private</code>）以便禁止他人创建实例，保证了只能创建一个实例。可以对外提出个静态方法<code>insatance</code>，在需要的时候创建该实例，只有该实例为<code>null</code>的时候才创建，保证避免重复创建。</p>
<h2 id="解法二：适用多线程，效率不高-懒汉"><a href="#解法二：适用多线程，效率不高-懒汉" class="headerlink" title="解法二：适用多线程，效率不高(懒汉)"></a>解法二：适用多线程，效率不高(懒汉)</h2><p>​        解法一在单线程工作正常，但是在多线程可能就会出现问题了。如果两个线程同时运行判断<code>me</code>是否为<code>null</code>的语句，并且确实没有创建时，那么两个线程都会创建一个实例，此时就不满足单例了。为了多线程下还是单例，我们需要加一个<code>同步锁</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton2 me;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();	<span class="comment">//这个锁大家都要认识的static</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">			<span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">				me = <span class="keyword">new</span> Singleton2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> me;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        由于一个时刻只有一个线程能得到同步锁，当第一个线程加上锁时，第二个线程只能等待。第一个线程创建好实例后，释放同步锁，此时第二个线程加上同步锁，并运行接下来代码，由于第一个线程已经创建实例了，第二个线程就不会重复创建实例了。这样就保证了在多线程环境下也只得到一个实例。</p>
<h2 id="解法三：加同步锁两次判断实例是否存在"><a href="#解法三：加同步锁两次判断实例是否存在" class="headerlink" title="解法三：加同步锁两次判断实例是否存在"></a>解法三：加同步锁两次判断实例是否存在</h2><p>​        但是解法二依然不是很完美。我们每次调用方法<code>instance()</code>时候，都会加上一个锁，而加锁是一个十分耗时的操作，没有必要的时候尽量应该避免。</p>
<p>​        我们只是在实例还没有创建之前时才需要锁，当实例已经存在后就不需要加锁了，于是我们可以继续优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 me;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (me != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> me;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">			<span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">				me = <span class="keyword">new</span> Singleton3();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">return</span> me;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <font color= red>需要注意的的是：加volatile关键字防止指令重排。</font></p>
<p>​        指令重排：简单来说，就是计算机为了提高执行效率，会做的一些优化，在不影响最终结果的情况下，可能会对一些语句的执行顺序进行调整。</p>
<p>​    <code>me = new Singleton3();</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ol>
<li><p>给me分配内存</p>
</li>
<li><p>调用Singleton3的构造函数来初始化成员变量，形成实例</p>
</li>
<li><p>将me对象指向分配的内存空间（执行完这步 singleton才是非 null了）</p>
<p>​    这在JVM的即时编译器中存在指令重排序的优化。</p>
<p>​    也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时me已经是非 null 了（但却没有初始化），所以线程二会直接返回me，然后使用，然后顺理成章地报错。</p>
<p>​    再稍微解释一下，就是说，由于有一个（me已经不为null但是仍没有完成初始化）的中间状态，而这个时候，如果有其他线程刚好运行到第一层if (me !=null)这里，这里读取到的instance已经不为null了，所以就直接把这个中间状态的me拿去用了，就会产生问题。这里的关键在于线程T1对me的写操作没有完成，线程T2就执行了读操作。</p>
<p>​    volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p><strong>I. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</strong></p>
<p><strong>II. 它会强制将对缓存的修改操作立即写入主存；</strong></p>
<p><strong>III. 如果是写操作，它会导致其他CPU中对应的缓存行无效。</strong></p>
<p>被volatile关键字修饰的变量，如果值发生了变更，其他线程立马可见，避免出现脏读的现象。把instance声明为volatile之后，对它的写操作就会有一个内存屏障，这样，在它的赋值完成之前，就不用会调用读操作。</p>
<p><strong>注意：volatile阻止的不是singleton = new Singleton()这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（if (instance == null)）。</strong></p>
<p><strong>……，欢迎指正！</strong></p>
</li>
</ol>
<h2 id="解法四：利用静态块（饿汉模式）"><a href="#解法四：利用静态块（饿汉模式）" class="headerlink" title="解法四：利用静态块（饿汉模式）"></a>解法四：利用静态块（饿汉模式）</h2><p>​        Java中有一段代码可以保证只调用一次那就是静态块（static）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungerSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> HungerSingleton me;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		me = <span class="keyword">new</span> HungerSingleton();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">HungerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HungerSingleton <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> me;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        因为静态块在类加载的时候才被调用，并且只调用一次，所以它可以保证单例。并且只有类被加载了，才去创建实例。也就是说第一次用到<code>LazySingleton</code>这个类实例就会被创建。</p>
<p>​        但是问题是，假设我们在<code>LazySingleton</code>类里添加一个静态方法，调用该静态方法是不需要创建一个实例的，但如果用<code>饿汉模式</code>，则会过早的创建实例，从而降低了内存的使用效率。</p>
<h2 id="解法五：按需创建实例"><a href="#解法五：按需创建实例" class="headerlink" title="解法五：按需创建实例"></a>解法五：按需创建实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> inner.singleton;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">inner</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton4 singleton = <span class="keyword">new</span> Singleton4();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在这个单例模式中，我们定义了个内部类。该内部类的实例与外部类实例没有绑定关系，而且只有调用<code>Singleton4.instance()</code>的时候才会装载，从而实现了延迟加载。如果我们不调用上述方法，就不会实例化对象，这样达到了按需创建。</p>
<h1 id="String类为什么要设计final的？"><a href="#String类为什么要设计final的？" class="headerlink" title="String类为什么要设计final的？"></a>String类为什么要设计final的？</h1><p>​        final修饰一个类，说明这个类不可以被继承，防止被破坏。</p>
<p>1.String类不可变性，源码<code>private final char value[];</code>，value地址值在stack空间里，真正指向是一段heap空间，因为这个特性申请的地址不可变，而里面的数据可以变。设置为private，就是为了不对里面进行操作，防止破坏，里面都是底层操作，有的甚至和os有关，所以要封装起来。不给外人机会对内部进行操作，防止破坏。</p>
<p>2.因为不可变性，可以作为HashMap的键值。HashMap键值千万不能用可变类型，破坏键值唯一性。</p>
<p>3.线程安全。在并发场景下，多个线程同时读一个资源没关系，多个线程对同一个资源做写的操作就有危险，不可变对象不能被写，所以线程安全。</p>
<p>4.字符串常量池。<code>String a = &quot;something String b = &quot;something&quot;</code>其实它们都指向同一个内存地址。在大量使用字符串的情况下，节省内存空间。</p>
<p><strong>总而言之，为了安全和效率，这就是工具设计最终目标。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://honorzmj98.github.io/2020/09/23/20200923@%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F@String%E8%A2%ABfinal%E4%BF%AE%E9%A5%B0/" data-id="ckfg6npn400076gi2350gg19m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/09/16/20200916@ORM/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">20200916@ORM</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/23/20200923@%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F@String%E8%A2%ABfinal%E4%BF%AE%E9%A5%B0/">20200923@单例模式@String被final修饰</a>
          </li>
        
          <li>
            <a href="/2020/09/16/20200916@ORM/">20200916@ORM</a>
          </li>
        
          <li>
            <a href="/2020/09/13/20200913@swing/">20200913@swing</a>
          </li>
        
          <li>
            <a href="/2020/09/11/20200911@%E6%8E%A5%E5%8F%A3@%E6%8E%92%E5%BA%8F/">20200911@接口@排序</a>
          </li>
        
          <li>
            <a href="/2020/04/08/20200408@%E6%A8%A1%E6%8B%9F%E7%AE%80%E6%98%93Spring/">20200408@模拟简易Spring</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 HonorZmj98<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>